#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Simulate genealogies"""
import os
import re
import pathlib
import collections
import tempfile
import json
import tskit
import msprime
import cyvcf2


def map_individuals_to_population(ts):
    d = dict(
        [
            (n.individual, ts.population(n.population))
            for n in ts.nodes()
            if n.individual >= 0
        ]
    )
    return d


def make_indv_names(individuals):
    # We require that the tree sequence was generated by a demes model
    # where 'name' is a required attribute
    # indv_names = ([f"{v.metadata['name']}_{k}" for k, v in individuals.items()])
    i = 0
    indv_names = []
    oldname = None
    for k, v in individuals.items():
        name = v.metadata["name"]
        if oldname is not None and oldname != name:
            i = 0
        indv_names.append(f"{name}_{k}_{i}")
        i = i + 1
        oldname = name
    return list(individuals.keys()), indv_names


def prepare_ref(ts, ref, indv_names, indv_ids):
    def _make_popdict():
        # Want population to individual mapping!
        popdict = collections.defaultdict(dict)
        for n in ts.nodes():
            if n.individual == -1:
                continue
            pop = ts.population(n.population).metadata["name"]
            if pop not in popdict.keys():
                popdict[pop] = list()
            if n.individual not in popdict[pop]:
                popdict[pop].append(n.individual)
        return popdict

    popdict = _make_popdict()
    popid_to_name = dict(
        [(k, ts.population(k).metadata["name"]) for k in range(len(ts.populations()))]
    )
    m = re.match(r"(?P<pop>\d+|\S+):(?P<ind>\d+)", ref)
    try:
        refpop, refind = m.groupdict()["pop"], int(m.groupdict()["ind"])
    except AttributeError as e:
        print(e)
        raise

    if re.match(r"\d+", refpop) is not None:
        try:
            refpop = popid_to_name[int(refpop)]
        except Exception as e:
            print(e)
            raise

    reference_ind = popdict[refpop][refind]
    indv_ids.pop(reference_ind)
    return indv_names[reference_ind], [indv_names[i] for i in indv_ids]


def run(
    tsfile, ref=None, prefix="simseqgen", outdir=pathlib.Path(os.curdir), single=False
):
    ts = tskit.load(tsfile)
    individuals = map_individuals_to_population(ts)
    indv_ids, indv_names = make_indv_names(individuals)

    tmpvcf = tempfile.mkstemp(suffix=".vcf")[1]
    with open(tmpvcf, "w") as fh:
        ts.write_vcf(fh, individual_names=indv_names)

    vcfout = outdir / f"{prefix}.vcf.gz"
    if ref is not None:
        refseq_sample, indv_names = prepare_ref(ts, ref, indv_names, indv_ids)
        refout = outdir / f"{prefix}.fasta"
        refseq = cyvcf2.VCF(tmpvcf, samples=refseq_sample)

    vcf = cyvcf2.VCF(tmpvcf, samples=indv_names)
    vcfwriter = cyvcf2.cyvcf2.Writer(str(vcfout), vcf, "wz")
    if ref is None:
        vcfwriter.set_samples(vcf.samples)
        for variant in vcf:
            vcfwriter.write_record(variant)
    else:
        # write function that does this
        # in cyvcf2: Pick one individual *haplotype* as reference: this
        # individual should have only 0's, so all calls at a site with a
        # derived allele should be flipped for all individuals.
        for gt, variant in zip(refseq, vcf):
            ref = gt.genotypes[0][0]
            if ref == 1:
                # Flip states for all other genotypes - or randomly?
                for i in range(len(variant.genotypes)):
                    alleles = variant.genotypes[i]
                    variant.genotypes[i] = [1 - alleles[0], 1 - alleles[1], alleles[2]]
                variant.genotypes = variant.genotypes
                variant.REF = gt.ALT[0]
                variant.ALT = [gt.REF]
            vcfwriter.write_record(variant)

    vcfwriter.close()
