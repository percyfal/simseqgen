#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Simulate genealogies"""
import os
import re
import pathlib
import collections
import itertools
import tempfile
from random import choices
import json
import tskit
import msprime
import cyvcf2
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
import logging

FORMAT = "%(levelname)s:simseqgen:%(asctime)-15s %(message)s"
logging.basicConfig(format=FORMAT, level=logging.DEBUG)
logger = logging.getLogger("simseqgen")


def tskit_individuals(ts):
    return [f"tsk_{ind.id}" for ind in ts.individuals()]


def map_individuals_to_population(ts):
    """Map individuals to population"""
    d = {
        n.individual: ts.population(n.population)
        for n in ts.nodes()
        if n.individual >= 0
    }
    return d


def make_indv_names(indv_to_pop):
    """Make unique sample adding population and within-population individual id to default tsk name"""
    # We require that the tree sequence was generated by a demes model
    # where 'name' is a required attribute
    # indv_names = ([f"{v.metadata['name']}_{k}" for k, v in individuals.items()])
    i = 0
    indv_names = []
    oldname = None
    for k, v in indv_to_pop.items():
        name = v.metadata["name"]
        if oldname is not None and oldname != name:
            i = 0
        indv_names.append(f"tsk_{k}_{name}_{i}")
        i = i + 1
        oldname = name
    return list(indv_to_pop.keys()), indv_names


def tsk_id_metadata(ts):
    """Map tsk_id to dictionary containing metadata"""
    tsk_id = collections.defaultdict(dict)
    indv_to_pop = map_individuals_to_population(ts)
    _, indv_names = make_indv_names(indv_to_pop)
    for tsid, ind in zip(tskit_individuals(ts), indv_to_pop.keys()):
        md = {
            "desc": (
                f"tskit individual {tsid}, name {indv_names[ind]}, "
                f"population {indv_to_pop[ind]}"
            ),
            "tskit_id": tsid,
            "index": ind,
            "name": indv_names[ind],
            "population": None,
            "is_reference": False,
        }
        tsk_id[tsid] = md
    return tsk_id


def update_individual_metadata(ts):
    """Update individual metadata in ts object.

    Returns new list of individuals with updated metadata
    """
    indv_to_pop = map_individuals_to_population(ts)
    _, indv_names = make_indv_names(indv_to_pop)
    individuals = []
    for ind in ts.individuals():
        md = {
            "id": ind.id,
            "tskit_id": f"tsk_{ind.id}",
            "name": indv_names[ind.id],
            "popname": indv_to_pop[ind.id].metadata["name"],
            "popindex": indv_names[ind.id].split("_")[3],
            "population": indv_to_pop[ind.id],
            "description": (
                f"tskit individual tsk_{ind.id}, name {indv_names[ind.id]}, "
                f"population {indv_to_pop[ind.id]}"
            ),
            "is_reference": False,
        }
        md["vcfheader"] = (
            f"##<SAMPLE=<ID={md['tskit_id']},Name={md['name']},Index={md['id']},Population={md['popname']},"
            f"Description=\"{md['population'].metadata['description']}\">"
        )
        newind = ind.replace(metadata=md)
        individuals.append(newind)
    return individuals


def set_reference_ind(ts, ref):
    """Identify reference individual index.

    Partition indv_names to reference_id and remaining ids

    Return:
      reference_ind_id (str): reference individual id formatted as tsk_{id}
    """

    def _make_popdict():
        # Want population to individual mapping!
        popdict = collections.defaultdict(dict)
        for n in ts.nodes():
            if n.individual == -1:
                continue
            pop = ts.population(n.population).metadata["name"]
            if pop not in popdict.keys():
                popdict[pop] = list()
            if n.individual not in popdict[pop]:
                popdict[pop].append(n.individual)
        return popdict

    popdict = _make_popdict()
    popid_to_name = {
        k: ts.population(k).metadata["name"] for k in range(len(ts.populations()))
    }
    m = re.match(r"(?P<pop>\d+|\S+):(?P<ind>\d+)", ref)
    try:
        refpop, refind = m.groupdict()["pop"], int(m.groupdict()["ind"])
    except AttributeError as e:
        print(e)
        raise

    if re.match(r"\d+", refpop) is not None:
        try:
            refpop = popid_to_name[int(refpop)]
        except Exception as e:
            print(e)
            raise

    reference_ind = popdict[refpop][refind]
    individuals = update_individual_metadata(ts)
    individuals[reference_ind].metadata["is_reference"] = True
    return reference_ind, individuals


def make_sequence(ts, index, reference):
    """Create DNA sequence with variants at sites"""
    seqid = f"tsk_{list(ts.individuals())[index].id}"
    indv_to_pop = map_individuals_to_population(ts)
    _, indv_names = make_indv_names(indv_to_pop)
    for site, variant in zip(ts.sites(), list(ts.haplotypes())[index]):
        i = int(site.position)
        reference[i] = variant
    desc = (
        f"tskit individual {index}, name {indv_names[index]}, "
        f"population {indv_to_pop[index]}"
    )
    record = SeqRecord(
        Seq("".join(reference)), name=indv_names[index], id=seqid, description=desc
    )
    return record


def write_variants(ts, vcf_tmp_fn, ref_ind, outdir, prefix):
    """Write variants to output vcf. If reference vcf is provided flip alleles where necessary"""

    def _filter_reference(ind):
        return ind.metadata["is_reference"]

    vcf_ref = None
    if ref_ind is not None:
        ref_ind, individuals = set_reference_ind(ts, ref_ind)
        vcf_ref = cyvcf2.VCF(
            vcf_tmp_fn, samples=individuals[ref_ind].metadata["tskit_id"]
        )

    vcf_out = outdir / f"{prefix}.vcf.gz"
    logger.info(f"Writing output vcf {vcf_out}")
    samples = [
        ind.metadata["tskit_id"]
        for ind in itertools.filterfalse(_filter_reference, individuals)
    ]
    vcf_tmp = cyvcf2.VCF(vcf_tmp_fn, samples=samples)
    # Add header information to vcf
    # Need to exclude reference from vcfout?
    vcfwriter = cyvcf2.cyvcf2.Writer(str(vcf_out), vcf_tmp, "wz")
    for ind in itertools.filterfalse(_filter_reference, individuals):
        vcfwriter.add_to_header(ind.metadata["vcfheader"])
    if vcf_ref is None:
        vcfwriter.set_samples(vcf_tmp.samples)
        for variant in vcf_tmp:
            vcfwriter.write_record(variant)
    else:
        # write function that does this
        # in cyvcf2: Pick one individual *haplotype* as reference: this
        # individual should have only 0's, so all calls at a site with a
        # derived allele should be flipped for all individuals.
        for gt, variant in zip(vcf_ref, vcf_tmp):
            ref = gt.genotypes[0][0]
            if ref == 1:
                # Flip states for all other genotypes - or randomly?
                for i in range(len(variant.genotypes)):
                    alleles = variant.genotypes[i]
                    variant.genotypes[i] = [1 - alleles[0], 1 - alleles[1], alleles[2]]
                variant.genotypes = variant.genotypes
                variant.REF = gt.ALT[0]
                variant.ALT = [gt.REF]
            vcfwriter.write_record(variant)
    vcfwriter.close()


def run(
    tsfile,
    ref_ind=None,
    prefix="simseqgen",
    outdir=pathlib.Path(os.curdir),
    single=False,
    refseq_fn=None,
):
    """Runner to generate vcf and fasta output from a tree sequence

    Args:
      tsfile (str): tree sequence file name
      ref_ind (str): reference individual identifier formatted as
        <population_id>:<individual_index>, where the index refers to
        the index within the population
      prefix (str): prefix of output files
      outdir (path): output directory path
      single (bool): write fasta sequences to separate files
      refseq_fn (str): reference sequence file name to base output

    """
    ts = tskit.load(tsfile)

    vcf_tmp_fn = tempfile.mkstemp(suffix=".vcf")[1]
    logger.info(f"Writing temporary ts vcf {vcf_tmp_fn}")
    with open(vcf_tmp_fn, "w") as fh:
        ts.write_vcf(fh)

    write_variants(ts, vcf_tmp_fn, ref_ind, outdir, prefix)

    logger.info("Writing fasta sequences")
    # Make fasta sequences
    reference = None
    if refseq_fn is None:
        dna = ["A", "C", "G", "T"]
        reference = choices(dna, k=int(ts.sequence_length))
    if not single:
        refout = outdir / f"{prefix}.fasta"
        fh = open(refout, "w")
    for i in range(ts.num_individuals):
        rec = make_sequence(ts, i, reference)
        if single:
            SeqIO.write(rec, f"{rec.id}.fasta", "fasta")
        else:
            SeqIO.write(rec, fh, "fasta")
