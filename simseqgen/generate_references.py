#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Simulate genealogies"""
import os
import re
import pathlib
import collections
import itertools
import tempfile
from random import choices
import tskit
import msprime
import cyvcf2
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
import logging

FORMAT = "%(levelname)s:simseqgen:%(asctime)-15s %(message)s"
logging.basicConfig(format=FORMAT, level=logging.INFO)
logger = logging.getLogger("simseqgen")


def map_individuals_to_population(ts):
    """Map individuals to population"""
    d = {
        n.individual: ts.population(n.population)
        for n in ts.nodes()
        if n.individual >= 0
    }
    return d


def make_indv_names(indv_to_pop):
    """Make unique individual names

    Add population and within-population individual id to default tsk
    name

    """
    # We require that the tree sequence was generated by a demes model
    # where 'name' is a required attribute
    i = 0
    indv_names = []
    oldname = None
    for k, v in indv_to_pop.items():
        name = v.metadata["name"]
        if oldname is not None and oldname != name:
            i = 0
        indv_names.append(f"tsk_{k}_{name}_{i}")
        i = i + 1
        oldname = name
    return list(indv_to_pop.keys()), indv_names


def update_individual_metadata(ts):
    """Update individual metadata in ts object.

    Returns new list of individuals with updated metadata
    """
    indv_to_pop = map_individuals_to_population(ts)
    _, indv_names = make_indv_names(indv_to_pop)
    individuals = []
    for ind in ts.individuals():
        md = {
            "id": ind.id,
            "tskit_id": f"tsk_{ind.id}",
            "name": indv_names[ind.id],
            "popname": indv_to_pop[ind.id].metadata["name"],
            "popindex": indv_names[ind.id].split("_")[3],
            "population": indv_to_pop[ind.id],
            "description": (
                f"tskit individual tsk_{ind.id}, name {indv_names[ind.id]}, "
                f"population {indv_to_pop[ind.id]}"
            ),
            "is_reference": False,
        }
        md["vcfheader"] = (
            f"##<SAMPLE=<ID={md['tskit_id']},Name={md['name']},"
            f"Index={md['id']},Population={md['popname']},"
            f"Description=\"{md['population'].metadata['description']}\">"
        )
        newind = ind.replace(metadata=md)
        individuals.append(newind)
    return individuals


def set_reference_individual(ts, ref):
    """Identify and set reference individual

    Also add metadata to individuals.

    Returns:
      ref_ind (tskit.util.Dataclass.Individual): reference individual
      individuals (list(tskit.util.Dataclass.Individual)): individuals
        with updated metadata
    """

    def _make_popdict():
        # Want population to individual mapping!
        popdict = collections.defaultdict(dict)
        for n in ts.nodes():
            if n.individual == -1:
                continue
            pop = ts.population(n.population).metadata["name"]
            if pop not in popdict.keys():
                popdict[pop] = list()
            if n.individual not in popdict[pop]:
                popdict[pop].append(n.individual)
        return popdict

    popdict = _make_popdict()
    popid_to_name = {
        k: ts.population(k).metadata["name"] for k in range(len(ts.populations()))
    }
    m = re.match(r"(?P<pop>\d+|\S+):(?P<ind>\d+)", ref)
    try:
        refpop, refind = m.groupdict()["pop"], int(m.groupdict()["ind"])
    except AttributeError as e:
        print(e)
        raise

    if re.match(r"\d+", refpop) is not None:
        try:
            refpop = popid_to_name[int(refpop)]
        except Exception as e:
            print(e)
            raise

    index = popdict[refpop][refind]
    individuals = update_individual_metadata(ts)
    individuals[index].metadata["is_reference"] = True

    return individuals[index], individuals


def make_sequence(ts, index, reference):
    """Create DNA sequence with variants at sites"""
    seqid = f"tsk_{list(ts.individuals())[index].id}"
    indv_to_pop = map_individuals_to_population(ts)
    _, indv_names = make_indv_names(indv_to_pop)
    for site, variant in zip(ts.sites(), list(ts.haplotypes())[index]):
        i = int(site.position)
        reference[i] = variant
    desc = (
        f"tskit individual {index}, name {indv_names[index]}, "
        f"population {indv_to_pop[index]}"
    )
    record = SeqRecord(
        Seq("".join(reference)), name=indv_names[index], id=seqid, description=desc
    )
    return record


def write_variants(ts, vcf_tmp_fn, reference_chromosome, outdir, prefix):
    """Write variants to output vcf.

    If reference vcf is provided flip alleles where necessary
    """

    def _filter_reference(ind):
        return ind.metadata["is_reference"]

    vcf_ref = None
    if reference_chromosome is not None:
        ref_ind, individuals = set_reference_individual(ts, reference_chromosome)
        vcf_ref = cyvcf2.VCF(vcf_tmp_fn, samples=ref_ind.metadata["tskit_id"])

    vcf_out = outdir / f"{prefix}.vcf.gz"
    logger.info(f"Writing output vcf {vcf_out}")
    samples = [
        ind.metadata["tskit_id"]
        for ind in itertools.filterfalse(_filter_reference, individuals)
    ]
    vcf_tmp = cyvcf2.VCF(vcf_tmp_fn, samples=samples)
    vcfwriter = cyvcf2.cyvcf2.Writer(str(vcf_out), vcf_tmp, "wz")
    for ind in itertools.filterfalse(_filter_reference, individuals):
        vcfwriter.add_to_header(ind.metadata["vcfheader"])
    if vcf_ref is None:
        vcfwriter.set_samples(vcf_tmp.samples)
        for variant in vcf_tmp:
            vcfwriter.write_record(variant)
    else:
        # in cyvcf2: Pick one individual *haplotype* as reference: this
        # individual should have only 0's, so all calls at a site with a
        # derived allele should be flipped for all individuals.
        for gt, variant in zip(vcf_ref, vcf_tmp):
            ref = gt.genotypes[0][0]
            if ref == 1:
                # Flip states for all other genotypes
                for i in range(len(variant.genotypes)):
                    alleles = variant.genotypes[i]
                    variant.genotypes[i] = [1 - alleles[0], 1 - alleles[1], alleles[2]]
                variant.genotypes = variant.genotypes
                variant.REF = gt.ALT[0]
                variant.ALT = [gt.REF]
            vcfwriter.write_record(variant)
    vcfwriter.close()


def run(
    *,
    tsfile,
    reference_chromosome=None,
    prefix="simseqgen",
    outdir=pathlib.Path(os.curdir),
    single=False,
    refseq_fn=None,
):
    """Runner to generate vcf and fasta output from a tree sequence

    Args:
      tsfile (str): tree sequence file name
      reference_chromosome (str): reference chromosome identifier formatted as
        <population_id>:<individual_index>, where the index refers to
        the index within the population
      prefix (str): prefix of output files
      outdir (path): output directory path
      single (bool): write fasta sequences to separate files
      refseq_fn (str): reference sequence file name to base output

    """
    ts = tskit.load(tsfile)

    vcf_tmp_fn = tempfile.mkstemp(suffix=".vcf")[1]
    logger.info(f"Writing temporary ts vcf {vcf_tmp_fn}")
    with open(vcf_tmp_fn, "w") as fh:
        ts.write_vcf(fh)

    write_variants(ts, vcf_tmp_fn, reference_chromosome, outdir, prefix)

    logger.info("Writing fasta sequences")
    # Make fasta sequences
    reference = None
    if refseq_fn is None:
        dna = ["A", "C", "G", "T"]
        reference = choices(dna, k=int(ts.sequence_length))
    if not single:
        refout = outdir / f"{prefix}.fasta"
        fh = open(refout, "w")
    for i in range(ts.num_individuals):
        rec = make_sequence(ts, i, reference)
        if single:
            SeqIO.write(rec, f"{rec.id}.fasta", "fasta")
        else:
            SeqIO.write(rec, fh, "fasta")
